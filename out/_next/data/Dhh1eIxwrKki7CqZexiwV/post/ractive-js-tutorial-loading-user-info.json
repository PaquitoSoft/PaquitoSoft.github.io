{"pageProps":{"post":{"slug":"ractive-js-tutorial-loading-user-info","title":"Ractive.js tutorial - Loading user info (4 of 6)","creationDate":"2015-08-01T19:08:30.642Z","keywords":"tutorial, javascript, ractive, ractivejs","status":"published","excerpt":"<p>(<em>Previous step</em>: <a href=\"/post/ractive-js-tutorial-routing\">Routing</a>)</p>\n<p>Rigth now our page shows nothing but some labels.\nThe next step is to allow our users to search for a GitHub user and, if it's found, show his info in the specific page.</p>\n<p>We will be requesting data to the <a href=\"https://developer.github.com/v3/\">GitHub REST API</a>.\nThese are the endpoints we'll be hitting:</p>\n<ul>\n<li>https://api.github.com/users/{username}: Get user main info</li>\n<li>https://api.github.com/users/{username}/repos: Get user's repositories data</li>\n</ul>\n<h2>Polyfills</h2>\n<p>To implement third party integration, we will be usign two new <em>ES2015</em> APIs which are not already arrived to all browsers, so we need to include some polyfills in our application for them: <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\">fetch</a> and <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\">Promise</a>.</p>\n<p>We will need to update our <strong>webpack</strong> configuration to include in our JS bundle these polyfills.</p>\n<p>First, we need to install the polyfills and a couple of <em>webpack</em> plugins:</p>\n<pre><code>$ npm install es6-promise whatwg-fetch --save\n$ npm install imports-loader exports-loader --save-dev\n</code></pre>\n","content":"<p>(<em>Previous step</em>: <a href=\"/post/ractive-js-tutorial-routing\">Routing</a>)</p>\n<p>Rigth now our page shows nothing but some labels.\nThe next step is to allow our users to search for a GitHub user and, if it's found, show his info in the specific page.</p>\n<p>We will be requesting data to the <a href=\"https://developer.github.com/v3/\">GitHub REST API</a>.\nThese are the endpoints we'll be hitting:</p>\n<ul>\n<li>https://api.github.com/users/{username}: Get user main info</li>\n<li>https://api.github.com/users/{username}/repos: Get user's repositories data</li>\n</ul>\n<h2>Polyfills</h2>\n<p>To implement third party integration, we will be usign two new <em>ES2015</em> APIs which are not already arrived to all browsers, so we need to include some polyfills in our application for them: <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\">fetch</a> and <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\">Promise</a>.</p>\n<p>We will need to update our <strong>webpack</strong> configuration to include in our JS bundle these polyfills.</p>\n<p>First, we need to install the polyfills and a couple of <em>webpack</em> plugins:</p>\n<pre><code>$ npm install es6-promise whatwg-fetch --save\n$ npm install imports-loader exports-loader --save-dev\n</code></pre>\n<p>Now, we update the <em>webpack</em> configuration file:</p>\n<pre><code class=\"language-javascript\">var webpack = require('webpack');\n\nmodule.exports = {\n\tentry: './app/js/app.js',\n\toutput: {\n\t\tfilename: 'app/js/dist/bundle.js'\n\t},\n\tmodule: {\n\t\tloaders: [\n\t\t\t{\n\t\t\t\ttest: /\\\\.js$/,\n\t\t\t\texclude: /(node_modules|bower_components)/,\n\t\t\t\tloader: 'babel'\n\t\t\t},\n\t\t\t{\n\t\t\t\ttest: /\\\\.html$/,\n\t\t\t\tloader: 'raw'\n\t\t\t}\n\t\t]\n\t},\n\t// This is to load polyfills (http://mts.io/2015/04/08/webpack-shims-polyfills/)\n\tplugins: [\n\t\tnew webpack.ProvidePlugin({\n\t\t\tfetch: 'imports?this=&gt;global!exports?global.fetch!whatwg-fetch',\n\t\t\t'es6-promise': 'es6-promise'\n\t\t})\n\t]\n};\n</code></pre>\n<h2>Search user component</h2>\n<p>Before we make any request, we must update our <em>SearchUser</em> component to handle username submission and navigate to user page.\nJust update its <em>searchUser</em> <a href=\"http://docs.ractivejs.org/latest/proxy-events\">proxy event</a> to get the username introduced by our user and try to navigate to the corresponding URL.\n<strong><em>root-folder</em>/app/js/components/layout/search-user.js</strong></p>\n<pre><code class=\"language-javascript\">import Ractive from 'ractive';\nimport Template from '../../../views/layout/search-user.html';\nimport * as router from '../../plugins/router';\n\nvar SearchGithub = Ractive.extend({\n\tisolated: true,\n\ttemplate: Template,\n\n\toninit() {\n\t\tthis.on('searchUser', (rEvent) =&gt; {\n\t\t\trEvent.original.preventDefault();\n\t\t\trouter.navTo(`/user/${rEvent.context.query}`);\n\t\t\tthis.set('query', '');\n\t\t});\n\t},\n\n\tdata: {\n\t\t\tquery: ''\n\t}\n});\n\nexport default SearchGithub;\n</code></pre>\n<p>We've just imported the router plugin and configured the <em>serachUser</em> handler to call plugin's navigation function passing the URL we want to visit (note the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings\">string interpolation</a> to build the URL).</p>\n<p>Now, when we type a username and submit the form, our router will call our '/user/:username' URL handler (defined in our <em>/app/js/config/routes.js</em> file).\nWe need to update that handler to perform our action, in this case, load user's info and repos data.</p>\n<h2>Ajax plugin</h2>\n<p>Instead of implement all the logic to fetch user related data in the route handler, we'll be using several objects to separete concerns.\nIn one hand, we'll have a plugin to deal with <em>AJAX</em> request (we'll use the new, in progress, <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\">fetch API</a>). On the other hand we'll have a model object to represent a user so it will have all the logic related with users operations.</p>\n<p>Let's first create the ajax plugin:\n<strong><em>root-folder</em>/app/js/plugins/ajax.js</strong></p>\n<pre><code class=\"language-javascript\">function checkResponseStatus(res) {\n\tif (res.status &lt; 400) {\n\t\treturn res;\n\t} else {\n\t\tlet error = new Error(res.statusText);\n\t\terror.statusCode = res.status;\n\t\terror.response = res;\n\t\tthrow error;\n\t}\n}\n\nfunction parseJson(res) {\n\treturn new Promise((resolve) =&gt; {\n\t\tres.json().then(data =&gt; {\n\t\t\tresolve({\n\t\t\t\tjson: data,\n\t\t\t\turl: res.url\n\t\t\t});\n\t\t});\n\t});\n}\n\nexport function getJson(url) {\n\treturn fetch(url)\n\t\t.then(checkResponseStatus)\n\t\t.then(parseJson);\n}\n</code></pre>\n<p>Ok, this file exports a <em>getJson</em> function which allows to fetch JSON data and return a JS object.</p>\n<p>The <em>fetch</em> function returns a promise which will get a <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Response\">Response</a> object as response.\nWe chain that promise with another one which checks the response status and another one to extract the data from the json response.\nYou must remember something very important when using <em>fetch</em> function: if the endpoint responds with an error (for instance, a 4XX or 5XX response status code), the <em>fetch</em> function will not invoke the <em>reject</em> part of the promise it creates. That's why we need to first check for the status code of the response, before parsing its body.\nPersonally, I don't like this behavior and I hope this could change before closing this API specification.</p>\n<h2>User model</h2>\n<p>Next, we create our user <em>model</em>, where we encapsulate users state and behavior.\n<strong><em>root-folder</em>/app/js/models/user.js</strong></p>\n<pre><code class=\"language-javascript\">import * as ajax from '../plugins/ajax';\n\nconst GITHUB_BASE_URL = 'https://api.github.com';\n\nclass User {\n\t\n\tconstructor(profile, repos, notes) {\n\t\tthis.profile = profile;\n\t\tthis.repos = repos;\n\t\tthis.notes = notes || []; // Default parameters values are only valid for undefined ones\n\t}\n\n\tstatic findByName(username) {\n\t\tlet userProfileUrl = `${GITHUB_BASE_URL}/users/${username}`,\n\t\t\tuserReposUrl = `${GITHUB_BASE_URL}/users/${username}/repos`;\n\n\t\tlet result = new Promise((resolve, reject) =&gt; {\n\t\t\t\tPromise.all([\n\t\t\t\t\tajax.getJson(userProfileUrl),\n\t\t\t\tajax.getJson(userReposUrl),\n\t\t\t])\n\t\t\t.then(values =&gt; {\n\t\t\t\t\tresolve(new User(values[0], values[1]));\n\t\t\t})\n\t\t\t.catch(reject);\n\t\t});\n\n\t\treturn result;\n\t}\n}\n\nexport default User;\n</code></pre>\n<h2>Route handling</h2>\n<p>This is a <em>ES2015</em> class with its <em>constructor</em> function that gets invoked when we create a new instance and a <em>static</em> function which allows to call it without creating a new instance.\nSince our <em>ajax</em> plugin uses the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\"><em>fetch</em></a> API and it returns promises, here we use the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all\">Promise.all</a> function which allows to group several promises and get notified when all of them have completed (<em>or when one of them has failed</em>).</p>\n<p>Now we need to update our routing configuration so that when the user page URL gets requested, we use this user model object to fetch needed data.\n<strong><em>root-folder</em>/app/js/config/routes.js</strong></p>\n<pre><code class=\"language-javascript\">'use strict';\n\nimport router from '../plugins/router';\nimport HomePage from '../components/home-page';\nimport UserPage from '../components/user-page';\nimport UserModel from '../models/user';\n\nvar routes = new Map();\n\nroutes.set('/', (context, next) =&gt; {\n\tnext(null, HomePage);\n});\n\nroutes.set('/user/:username', (context, next) =&gt; {\n\tUserModel.findByName(context.params.username)\n\t.then((user) =&gt; {\n\t\t\tnext(null, UserPage, {\n\t\t\t\tuser: user\n\t\t});\n\t})\n\t.catch((err) =&gt; {\n\t\t\tnext(err);\n\t});\n});\n\nexport default routes;\n</code></pre>\n<p>We get the username from the context parameter and use it to call the user model <em>findByName</em> function so we get user's instance model object.\nWe then call <em>next</em> so the control gets to the <em>App</em> instance, which updates the <em>componentName</em> (page to be shown) and the request data.\nJust to remember...\n<strong><em>root-folder</em>/app/js/app.js</strong></p>\n<pre><code class=\"language-javascript\">...\nonNavigation(error, navigationContext) {\n\t\tconsole.log('APP::onNavigation# Navigating to:', navigationContext.pageName, 'with context:', navigationContext);\n\n\t\tif (error) {\n\t\t\tconsole.warn('App::onNavigation# Error navigating:', error);\n\t\t} else {\n\t\t\tthis.set({\n\t\t\t\treq: {\n\t\t\t\t\tparams: navigationContext.params,\n\t\t\t\t\tbody: navigationContext.state\n\t\t\t\t},\n\t\t\t\tcomponentName: navigationContext.pageName\n\t\t\t});\n\t\t}\n\t}\n...\n</code></pre>\n<p>Now we need to modify our user page component so, when the request data get updated, it updates its <em>user</em> data attribute so the presentation show the new data.\n<strong><em>root-folder</em>/app/js/components/user-page.js</strong></p>\n<pre><code class=\"language-javascript\">import Ractive from 'ractive';\nimport Template from '../../views/user-page.html';\nimport UserProfile from './user/profile-section';\nimport Repos from './user/repos-section';\nimport Notes from './user/notes-section';\n\nvar UserPage = Ractive.components.UserPage = Ractive.extend({\n\ttemplate: Template,\n\tcomponents: {\n\t\tUserProfile: UserProfile,\n\t\tRepos: Repos,\n\t\tNotes: Notes\n\t},\n\toninit() {\n\t\tthis.observe('req', (request) =&gt; {\n\t\t\tthis.set('user', request.body.user);\n\t\t});\n\t}\n});\nUserPage._name = 'UserPage';\n\nexport default UserPage;\n</code></pre>\n<p>When the page component is initialized, it begins observing for changes in the <em>req</em> data context attribute (which is handled by the <em>App</em> instance).\nAs we didn't set pages objects as isolated, they will get notified when that attribute gets updated.</p>\n<p>If you try to search for a user right now, you won't see any data in your browser, but you won't see any error neither. This is because there's something missing.\nRemember pages components are the only ones <em>non isolated</em>, so we need to pass the right user's data to its reusable components.\nWe need to update our user's page view:\n<strong><em>root-folder</em>/app/views/user-page.html</strong></p>\n<pre><code class=\"language-html\">&lt;div class=&quot;row&quot;&gt;\n\t&lt;div class=&quot;col-md-4&quot;&gt;\n\t\t&lt;UserProfile profile=&quot;{{user.profile}}&quot; /&gt;\n\t&lt;/div&gt;\n\t&lt;div class=&quot;col-md-4&quot;&gt;\n\t\t&lt;Repos repos=&quot;{{user.repos}}&quot; /&gt;\n\t&lt;/div&gt;\n\t&lt;div class=&quot;col-md-4&quot;&gt;\n\t\t&lt;Notes /&gt;\n\t&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<p>Now, if you load the app in your browser and search for a user, you must see his profile data and repos.\n<img src=\"/content/images/2015/08/ractive-tutorial-08.png\" alt=\"\"></p>\n<hr>\n<p>You can check the source code in <a href=\"https://github.com/PaquitoSoft/notetaker-ractive\">this GitHub repo</a>.</p>\n<hr>\n<p>Previous post: <a href=\"/post/ractive-js-tutorial-routing\">Routing</a>\nNext post: <a href=\"/post/ractive-js-tutorial-managing-users-notes\">Managing user's notes</a></p>\n<hr>\n"},"_superjson":{"values":{"post.creationDate":["Date"]}}},"__N_SSG":true}